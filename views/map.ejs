<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="X-UA-Compatible"/>
    <meta charset="utf-8"/>
    <meta
            name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"
    />

    <!--jquery and bootstrap-->
    <script src="https://code.jquery.com/jquery-latest.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
            crossorigin="anonymous"></script>

    <link rel="stylesheet" type="text/css" href="/stylesheets/map.css">

    <title>map Example</title>
</head>
<body style="overflow: hidden">
<div id="monitor">
    monitor
</div>
<div id="map" class="backgroundImg" onmousedown="startDrag(event, this)" onwheel="startWheel(event, this)">
    <p>원점</p>
</div>
<script type='text/javascript'>
    let img_L = 0;
    let img_T = 0;
    let targetObj;
    let mapData = [
        [0,0,1],
        [2,1,1],
        [3,2,3]];

    function getLeft(o) {
        return o.style.left.replace('px', '');
    }

    function getTop(o) {
        return o.style.top.replace('px', '');
    }

    // 이미지 움직이기
    function moveDrag(e) {
        var e_obj = window.event ? window.event : e;
        var dmvx = e_obj.clientX + img_L;
        var dmvy = e_obj.clientY + img_T;
        targetObj.style.left = dmvx + "px";
        targetObj.style.top = dmvy + "px";
        // console.log(e_obj.clientX, e_obj.clientY, img_L, img_T)
        return false;
    }

    // 드래그 시작
    function startDrag(e, obj) {
        console.log("Drag ST")
        gridMapDel();
        targetObj = obj;
        var e_obj = window.event ? window.event : e;
        img_L = getLeft(obj) - e_obj.clientX;
        img_T = getTop(obj) - e_obj.clientY;

        document.onmousemove = moveDrag;
        document.onmouseup = stopDrag;
        if (e_obj.preventDefault) e_obj.preventDefault();
    }

    // 드래그 멈추기
    function stopDrag() {
        gridMapLoad()
        document.onmousemove = null;
        document.onmouseup = null;
    }

    function startWheel(e, obj) {
        console.log("wheel ST")
        targetObj = obj;
        let e_obj = e;
        // console.log(e_obj.deltaY, e_obj.offsetX, e_obj.offsetY)
        let nowScale = Number(window.getComputedStyle(targetObj).transform.match(/matrix.*\((.+)\)/)[1].split(', ')[0]);
        let preScale = Number(nowScale - (e_obj.deltaY / 500));
        // console.log(preScale, e_obj.target.id);

        targetObj.style.transformOrigin = e_obj.offsetX + "px "+ e_obj.offsetY+ "px";

        if(0.8<preScale && preScale<7){
            console.log(preScale);
            targetObj.style.transform = "scale(" + preScale + ")";
        } else {
            targetObj.style.transform = "scale(" + nowScale + ")";
        }

        if (e_obj.preventDefault) e_obj.preventDefault();
    }

    window.onresize = function() {
        console.log(window.innerHeight);
        document.getElementById('monitor').style.height = window.innerHeight - 20 + 'px';
    }

    function gridMapDel() {
        $('.tile').remove();
    }

    function gridMapLoad() {
        const dc_div = document.createElement("div");
        const map = document.getElementById("map");
        console.log("m:", map.getBoundingClientRect().left, map.getBoundingClientRect().top);
        console.log("m:", map.getBoundingClientRect().width, map.getBoundingClientRect().height);
        console.log("b:", window.innerWidth, window.innerHeight);
        // get size
        const ml = map.getBoundingClientRect().left;
        const mt = map.getBoundingClientRect().top;
        const mw = map.getBoundingClientRect().width;
        const mh = map.getBoundingClientRect().height;
        const bw = window.innerWidth;
        const bh = window.innerHeight;
        // W, H (px)
        let mapView = [
            (ml<0?mw+ml:bw-ml),
            (mt<0?mh+mt:bh-mt)];
        // if bigger than window.inner
        mapView = [
            (bw<mapView[0]?bw:mapView[0]),
            (bh<mapView[1]?bh:mapView[1])];
        // if smaller than 0
        mapView = [
            (0>mapView[0]?0:mapView[0]),
            (0>mapView[1]?0:mapView[1])];
        console.log("mV:", mapView);

        // W, H (tile num)
        let mapViewTiles = [Math.floor(mapView[0]/44), Math.floor(mapView[1]/12.5)];
        console.log("mVT:", mapViewTiles);

        // set tiles
        let h, w, inLine=0;
        for (h=0;h<mapViewTiles[1]-3;h++){
            inLine = inLine===0 ? (44/2) : 0;
            for (w=0;w<mapViewTiles[0]-1;w++){
                const dc_p = document.createElement("p");
                dc_p.innerText = "⬣";
                let inPx = (44*w) + inLine;
                dc_p.setAttribute("style","top:"+String(12.5*h)+"px;left:"+String(inPx)+"px;");
                dc_p.setAttribute("class","tile");
                map.appendChild(dc_p);
            }
        }
    }
    gridMapLoad();
</script>
</body>
</html>
